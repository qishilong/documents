# Next.js 项目在 start 时期通过命令行向项目代码传环境变量方案

## 背景

项目在通过 `docker` 容器启动服务时，如果通过 `env` 文件的方法配置 `Next.js` 客户端组件需要的环境变量，在针对不同环境需要使用不同内容的 `env` 文件的场景下，就会导致每次项目打包之后生成的 `hash` 值发生改变，从而导致在部署时无法监听唯一的项目打包之后 的 `hash` 值，增加部署负担，所以需要找到一种可以无需修改 `env` 环境变量，直接在项目启动时通过命令行将环境变量传到项目代码中，从而保证每次项目在 `build` 过程中，项目里面没有文件变化，保证在部署过程中可以监听到唯一的 `hash` 值。

## 方案

`Next.js` 框架有一个特点，就是项目组件分为服务端组件和客户端组件，服务端组件可以引用客户端组件，但是客户端组件不能引用服务端组件，服务端组件可以通过 `props` 的方式可序列化的内容传给客户端组件，而且服务端组件可以通过 `process.env.xxx` 的方式读取到通过命令行传给项目代码的环境变量，这样就可以在 `RootLayout.tsx` 组件中读取环境变量，然后通过 `props` 的方式传给客户端组件，但是这样可能会导致客户端组件环境变量层级传递的特别深。

举个例子：

> 现在有一个客户端组件需要使用一个环境变量，就需要将这个环境变量通过 `props` 或者 `Context` 的方式传给这个客户端组件，如果这个客户端组件引用了一些在其他文件中的功能函数或者组件，而在这些功能函数或者组件里面也需要使用环境变量，就需要将这些环境变量通过 `props` 或者参数的方式传给这些功能函数或者组件，就会导致整个项目关于环境变量传递的层级特别深，不便于后期的维护。

为了解决以上例子遇到的问题，需要利用 `Next.js` 提供的 `Route Handlers` ，通过在客户端组件发起请求的方式从服务端获取环境变量，然后将环境变量作为请求返回的值返回给客户端，这样就能兼顾在客户端组件使用的功能函数中获取通过命令行传递的环境变量。

具体使用方式为：

在项目的根目录下（以 `App Router` 为例），在 `app` 的同级目录下创建 `api` 目录，在 `api` 目录中书写对应的文件名，同时也是对应的请求路径，比如请求代码写在了 `api/config/route.ts` 文件中，那么在客户端组件的功能函数中请求的地址为 `/api/config` ，然后只需要取接口返回的环境变量数据就可以了。不过有以下两点需要注意一下：

1. `api/config/route.ts` 文件会在 `Next.js` 框架打包时缓存请求结果（只针对 `GET` 请求），如果不想要产生缓存，同时还想要使用 `GET` 请求，可以将 `api/config/route.ts` 文件的声明为禁用缓存，方式为在文件顶部书写下面一行代码：

   ```ts
   export const dynamic = 'force-dynamic'
   ```

2. 如果使用在客户端组件发起请求的方式拿到环境变量，那么这个请求的详细信息可以在浏览器控制台的 `Network` 面板中看到，同时也可以看到请求返回的环境变量数据。为此可以使用 `Pako` 这个工具库将接口返回的数据转换为二进制数据，对环境变量数据进行加密，然后在客户端组件中再利用 `Pako` 将返回的二进制数据转换为正常的环境变量数据，这样在浏览器控制台的 `Network` 面板中看到获取环境变量的接口返回的数据就是转换后的二进制数据，不会将环境变量数据以明文的方式暴露出去。





