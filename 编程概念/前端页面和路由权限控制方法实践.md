# 前端页面和路由权限控制方法实践

## 方法一

### 只考虑根据后端返回的权限进行判断用户是否可以看到某些菜单项或者页面，不考虑用户手动输入路由进入无权限页面的情况

这种方法包括了对页面和菜单项的权限控制。页面主要是在子页面或者组件上包裹一层组件，然后在这个组件中判断用户是否有权限展示这个子组件或者页面；菜单项主要是在写菜单项配置时加上当前菜单项所需的权限，然后在编写菜单组件时，过滤掉没有权限的菜单配置项，然后再将过滤后的菜单配置项传给菜单组件。

这里还有一个兼容性的写法：如果当前用户拥有管理员权限但是没有某个子页面或者菜单项的权限，但是如果规定只要是管理员就拥有系统的所有权限，那么就可以在本地将管理员权限注入到每个子页面或者菜单项中。

```ts
export const adminKeys = ['ADMIN', 'RUN_AS_ADMIN'];
```

```tsx
import {adminKeys} from '@/constants/authedKeys';

const shouldWithAdminKeys = [...shouldKeys, ...adminKeys];
```

#### 对于页面

对于页面是否有权限展示实现一个权限控制组件包括要展示的页面或者子组件，传入要展示这个页面或者子组件所需的权限，然后进行判断用户是否有这个权限。

##### AuthLayout

```tsx
'use client';

import React from 'react';
import NoAuth from '../NoAuth/NoAuth';
import {AuthContainer} from '.';

interface AuthLayoutProps {
  needAuthKeys: string[];
  children: React.ReactNode;
}

const AuthLayout: React.FC<AuthedLayoutProps> = ({needAuthKeys, children}) => {
  const {hasAuth} = AuthContainer.useContainer();

  return <>{hasAuth(needAuthKeys) ? children : <NoAuth />}</>;
};

export default AuthLayout;
```

##### 子页面或者子组件

```tsx
import React, {Suspense} from 'react';
import AuthLayout from '@/components/Auth/AuthLayout';
import DashLayout from '@/components/Layout/DashLayout';

interface ManagementLayoutProps {
  children: React.ReactNode;
}

const ManagementLayout: React.FC<ManagementLayoutProps> = ({children}) => {
  return (
    <DashLayout>
      <Suspense>
        <AuthLayout needAuthKeys={['ADMIN']}>{children}</AuthLayout>
      </Suspense>
    </DashLayout>
  );
};

export default ManagementLayout;
```

#### 对于菜单

控制菜单项是否是在写菜单项配置时加上当前菜单项所需的权限，然后在编写菜单组件时，过滤掉没有权限的菜单配置项，然后再过滤后的菜单配置项传给菜单组件。

##### siderbarConfig 配置

```tsx
export const sidebarConfig: SiderBarConfig[] = [
  {
    platformName: '数据中心',
    platformKey: 'datasets',
    close: CLOSE_MENS_ARRAY.includes('datasets'),
    authKeys: ['VIEW_DATA', 'DATA_MGMT'],	// 配置的所需权限
    icon: (
      <Image
        alt="数据中心icon"
        height={12}
        src="/assets/images/layout/data-center-icon.svg"
        width={12}
      />
    ),
    icon2x: (
      <Image
        alt="数据中心icon"
        height={24}
        src="/assets/images/layout/data-center-icon.svg"
        width={24}
      />
    ),
    routers: [
      {
        label: '数据集管理',
        key: 'datasets/manage',
      },
      {
        label: '数据洞察',
        key: 'datasets/insight',
      },
      {
        label: '数据清洗',
        key: 'datasets/clean',
      },
      {
        label: '数据制备',
        key: 'datasets/prepare',
      },
    ],
  },
  {
    platformName: '模型评测',
    platformKey: 'evaluation',
    close: CLOSE_MENS_ARRAY.includes('evaluation'),
    authKeys: ['VIEW_EVAL', 'EVAL_MGMT'],
    icon: (
      <Image
        alt="模型评测icon"
        height={12}
        src="/assets/images/layout/model-evaluation-icon.svg"
        width={12}
      />
    ),
    icon2x: (
      <Image
        alt="模型评测icon"
        height={24}
        src="/assets/images/layout/model-evaluation-icon.svg"
        width={24}
      />
    ),
    routers: [
      {
        label: '自动评测',
        key: 'evaluation/model/auto',
      },
    ],
  }
  // ...
];
```

##### 菜单关闭之后的 item 元素

```tsx
const transformedSidebarConfig = useMemo(() => {
  // 如果没有权限，直接返回空数组
  if (!userInfo?.permissions) return [];
  return sidebarConfig
    .filter((item) => item.close === false)
    .filter((item) => {
      const needKeys = item.authKeys ? [...item.authKeys, ...adminKeys] : adminKeys;
      return needKeys.some((key) => userInfo.permissions.includes(key));
    })
    .map((item) => {
      return {
        label: item.platformName,
        key: item.platformKey,
        icon: item.icon2x,
        children: item.routers,
      };
    });
}, [userInfo?.permissions]);

const collapsedMenu = useMemo(() => {
  return (
    <Menu
      className={classNames('text-xs mt-5', styles.dashlayoutMenuCollaspsed)}
      items={transformedSidebarConfig}
      onSelect={({key}) => {
        router.push(`/${key}`);
      }}
      selectedKeys={[selectKey || 'datasets']}
    />
  );
}, [transformedSidebarConfig, selectKey, router]);
```

##### 菜单打开时的 item 元素

```tsx
const siderbarWithAuth = useMemo(() => {
  if (!userInfo?.permissions) return [];

  return sidebarConfig
    .filter((item) => item.close === false)
    .filter((item) => {
      const needKeys = item.authKeys ? [...item.authKeys, ...adminKeys] : adminKeys;
      return needKeys.some((key) => userInfo.permissions.includes(key));
    });
}, [userInfo?.permissions]);
```

##### Menu 菜单

```tsx
<Sider
  className={`${styles.sider} relative z-[801] shadow-[0px_0px_8px_0px_rgba(0,0,0,0.14)] py-1`}
  collapsed={collapsed}
  width={216}
>
  {collapsed
    ? collapsedMenu
    : siderbarWithAuth.map((item) => (
        <div key={item.platformKey}>
          <div className="flex gap-1 items-center my-3 ml-6">
            {item.icon}
            <span className="text-[10px] text-[#838F9A] font-[400] leading-[18px]">
              {item.platformName}
            </span>
          </div>
          <Menu
            className={classNames(styles.menuExpanded, 'text-xs')}
            items={item.routers}
            mode="inline"
            onOpenChange={(keys) => {
              setOpenKeys(keys);
            }}
            onSelect={({key}) => {
              router.push(`/${key}`);
            }}
            openKeys={openKeys}
            selectedKeys={[selectKey || 'knowledge/create']}
            style={{border: 'none'}}
          />
        </div>
      ))}
  {/* ... */}
</Sider>
```

### 考虑用户手动输入路由进入无权限页面的情况同时可以通过配置 `.env` 环境变量主动显隐藏菜单项和页面

主要思路是在 `siderbarConfig` 配置时补充用户是否有权限访问此菜单项和页面，同时对于当前页面或者路由包括的子页面或者子陆路由（比如动态路由）使用显示配置或者正则的方式判断。然后在将 `siderbarConfig` 配置应用到 `Menu` 菜单之前结合 `.env` 环境变量的配置对 `siderbarConfig` 配置进行匹配处理，同时在进入页面之前，判断用户是否有权限访问当前的路由。对于 `/login` 等这些无视系统权限的路由，添加**无视权限白名单**配置，并且优先处理**白名单**配置里的路由，对于考虑用户权限但是和 `siderbarConfig` 配置没有关系的路由，添加**考虑页面权限白名单**配置，处理优先级大于 `siderbarConfig` 配置的路由但是小于用户是否可见页面权限。

#### 对于 `.env` 环境变量

本地创建 `.env.local` 文件

在本地开发时，如果需要依赖于USS登录方式，需要创建`.env.local`文件，并将`.env.template.dev`复制到`.env.local`文件中。

`.env.template.dev` 文件内容：

```shell
# 区分使用环境，当前是USS环境
NEXT_PUBLIC_AUTH_TYPE=uss
# 要关闭的菜单项和页面，只有非USS环境下有效，如果要在本地开发POC环境内容，可以打开
# NEXT_PUBLIC_POC_CLOSE_MENU=datasets,evaluation,training,inference/model/manage
# USS环境地址
NEXT_PUBLIC_DEVELOPMENT_HOST=https://hanhai-dev.ai.ksyun.com
# POC环境地址
NEXT_PUBLIC_POC_HOST=https://hanhai-poc.ai.ksyun.com
```

#### 对于 `Menu` 配置

```tsx
'use client';
import {ConfigProvider, Layout, Menu} from 'antd';
import classNames from 'classnames';
import {useAtom} from 'jotai';
import {usePathname, useRouter} from 'next/navigation';
import React, {useEffect, useMemo, useState} from 'react';
import {sideBarRes} from '@/constants/sidebarConfig';
import {adminKeys} from '@/constants/authedKeys';
import Header from '../Header';
import {AuthContainer} from '../Auth';
import styles from './DashLayout.module.scss';
import {openKeysAtom} from './DashLayout.store';
import PageHeader from './PageHeader';

const {Sider} = Layout;
const LAYOUT_COLLAPSED_KEY = 'layout-collapsed';

interface DashLayoutProps {
  children: React.ReactNode;
}

const DashLayout: React.FC<DashLayoutProps> = ({children}) => {
  const pathName = usePathname();
  const defaultOpenKey = pathName.split('/')[1];
  const [openKeys, setOpenKeys] = useAtom(openKeysAtom);
  const router = useRouter();
  const selectKey = pathName.substring(1);
  const [collapsed, setCollapsed] = useState<boolean>(
    () => localStorage.getItem(LAYOUT_COLLAPSED_KEY) === 'true',
  );
  const {userInfo} = AuthContainer.useContainer();

  useEffect(() => {
    setOpenKeys((prev) => {
      if (prev.includes(defaultOpenKey)) {
        return prev;
      }
      return [defaultOpenKey, ...prev];
    });
  }, [defaultOpenKey, setOpenKeys]);

  const transformedSidebarConfig = useMemo(() => {
    // 如果没有权限，直接返回空数组
    if (!userInfo?.permissions) return [];

    return sideBarRes
      .filter((item) => {
        const needKeys = item.authKeys ? [...item.authKeys, ...adminKeys] : adminKeys;
        return needKeys.some((key) => userInfo.permissions.includes(key));
      })
      .map((item) => {
        return {
          label: item.platformName,
          key: item.platformKey,
          icon: item.icon2x,
          children: item.children,
        };
      });
  }, [userInfo?.permissions]);

  const collapsedMenu = useMemo(() => {
    return (
      <Menu
        className={classNames('text-xs mt-5', styles.dashlayoutMenuCollaspsed)}
        items={transformedSidebarConfig}
        onSelect={({key}) => {
          router.push(`/${key}`);
        }}
        selectedKeys={[selectKey || 'datasets']}
      />
    );
  }, [transformedSidebarConfig, selectKey, router]);

  const sidebarWithAuth = useMemo(() => {
    if (!userInfo?.permissions) return [];

    return sideBarRes.filter((item) => {
      const needKeys = item.authKeys ? [...item.authKeys, ...adminKeys] : adminKeys;
      return needKeys.some((key) => userInfo.permissions.includes(key));
    });
  }, [userInfo?.permissions]);

  return (
    <div className="h-screen flex flex-col" id="app">
      <Header />
      <div className="flex-1 h-0 flex flex-row bg-white overflow-hidden">
        <ConfigProvider theme={{token: {motion: false}}}>
          <Sider
            className={`${styles.sider} relative z-[801] shadow-[0px_0px_8px_0px_rgba(0,0,0,0.14)] py-1`}
            collapsed={collapsed}
            width={216}
          >
            {collapsed
              ? collapsedMenu
              : sidebarWithAuth.map((item) => (
                  <div key={item.platformKey}>
                    <div className="flex gap-1 items-center my-3 ml-6">
                      {item.icon}
                      <span className="text-[10px] text-[#838F9A] font-[400] leading-[18px]">
                        {item.platformName}
                      </span>
                    </div>
                    <Menu
                      className={classNames(styles.menuExpanded, 'text-xs')}
                      items={item.children}
                      mode="inline"
                      onOpenChange={(keys) => {
                        setOpenKeys(keys);
                      }}
                      onSelect={({key}) => {
                        router.push(`/${key}`);
                      }}
                      openKeys={openKeys}
                      selectedKeys={[selectKey || 'knowledge/create']}
                      style={{border: 'none'}}
                    />
                  </div>
                ))}
            <div
              className={classNames(
                'absolute right-0 top-1/2 -translate-y-1/2 translate-x-full cursor-pointer',
                styles.collapsedToggle,
              )}
              onClick={() => {
                setCollapsed((prev) => {
                  localStorage.setItem(LAYOUT_COLLAPSED_KEY, String(!prev));
                  return !prev;
                });
              }}
            >
              <div
                className={classNames(styles.collapsedIcon, {
                  [styles.collapsed]: collapsed,
                })}
              />
            </div>
          </Sider>
        </ConfigProvider>
        <div className="max-h-full flex flex-col flex-1 bg-[#F8F9FA] overflow-y-auto">
          <PageHeader />
          {children}
        </div>
      </div>
    </div>
  );
};

export default DashLayout;
```

#### 对于 `siderbarConfig` 配置和处理

```tsx
import Image from 'next/image';
import {type ReactNode} from 'react';

export interface SidebarChildren {
  label: string;
  key: string;
  icon?: ReactNode;
  children?: SidebarChildren[];
  authKeys?: string[];
  /* 是否关闭这个模块 */
  close?: boolean;
  /* 当前页面下有权限的页面，比如，当前页面路由是/inference/service/model/list，可以此页面上跳转并且有权限的路由，可能是子服务或者子功能的路由/inference/service/model/save，需要加到这个数组中作为授权，支持正则匹配和字符串两种方式 */
  hasAuthPathname?: (string | RegExp)[];
}

export interface SidebarConfig {
  platformName: string;
  platformKey: string;
  icon?: ReactNode;
  icon2x?: ReactNode;
  children?: SidebarChildren[];
  /**
   * 权限控制，参考文档
   * https://km.wps.cn/a/0fZPfZ5t
   */
  authKeys?: string[];
  /* 是否关闭这个模块 */
  close?: boolean;
  /* 当前页面下有权限的页面，比如，当前页面路由是/inference/service/model/list，可以此页面上跳转并且有权限的路由，可能是子服务或者子功能的路由/inference/service/model/save，需要加到这个数组中作为授权，支持正则匹配和字符串两种方式 */
  hasAuthPathname?: (string | RegExp)[];
}

const TYPE = process.env.NEXT_PUBLIC_AUTH_TYPE ?? 'uss';

export const sidebarConfig: SidebarConfig[] = [
  {
    platformName: '数据中心',
    platformKey: 'datasets',
    authKeys: ['VIEW_DATA', 'DATA_MGMT'],
    icon: (
      <Image
        alt="数据中心icon"
        height={12}
        src="/assets/images/layout/data-center-icon.svg"
        width={12}
      />
    ),
    icon2x: (
      <Image
        alt="数据中心icon"
        height={24}
        src="/assets/images/layout/data-center-icon.svg"
        width={24}
      />
    ),
    children: [
      {
        label: '数据集管理',
        key: 'datasets/manage',
        hasAuthPathname: [
          /^datasets\/manage\/raw\/addDatasets\/\d+$/,
          /^datasets\/manage\/raw\/detail\/\d+$/,
          /^datasets\/manage\/refined\/preview\/[^/]+$/,
          /^datasets\/manage\/refined\/task\/\d+$/,
          /^datasets\/manage\/refined\/versions\/[^/]+$/,
        ],
      },
      {
        label: '数据洞察',
        key: 'datasets/insight',
      },
      {
        label: '数据清洗',
        key: 'datasets/clean',
        hasAuthPathname: [
          /^datasets\/clean\/detail\/\d+$/,
          /^datasets\/clean\/execution\/detail\/\d+$/,
          /^datasets\/clean\/raw\/cleaningtask\/\d+$/,
        ],
      },
      {
        label: '数据制备',
        key: 'datasets/prepare',
        hasAuthPathname: [/^datasets\/prepare\/edit\/\d+$/],
      },
    ],
  },
  {
    platformName: '模型评测',
    platformKey: 'evaluation',
    authKeys: ['VIEW_EVAL', 'EVAL_MGMT'],
    icon: (
      <Image
        alt="模型评测icon"
        height={12}
        src="/assets/images/layout/model-evaluation-icon.svg"
        width={12}
      />
    ),
    icon2x: (
      <Image
        alt="模型评测icon"
        height={24}
        src="/assets/images/layout/model-evaluation-icon.svg"
        width={24}
      />
    ),
    children: [
      {
        label: '自动评测',
        key: 'evaluation/model/auto',
        hasAuthPathname: [
          /^evaluation\/model\/auto\/result\/\d+$/,
          'evaluation/model/auto/result/detail',
          'evaluation/model/auto/task/detail',
          'evaluation/model/auto/task/create',
          'evaluation/model/auto/task/edit',
        ],
      },
    ],
  },
  {
    platformName: '模型推理',
    platformKey: 'inference',
    authKeys: ['VIEW_INFER', 'INFER_MGMT'],
    icon: (
      <Image
        alt="推理平台icon"
        height={12}
        src="/assets/images/layout/inference-icon.svg"
        width={12}
      />
    ),
    icon2x: (
      <Image
        alt="推理平台icon"
        height={24}
        src="/assets/images/layout/inference-icon.svg"
        width={24}
      />
    ),
    children: [
      {
        label: '模型管理',
        key: 'inference/model/manage',
      },
      {
        label: '推理服务',
        key: 'inference/service',
        children: [
          {
            label: '服务列表',
            key: 'inference/service/model/list',
            hasAuthPathname: [
              /^inference\/service\/model\/detail\/\d+$/,
              'inference/service/model/save',
              'inference/service/model/history',
            ],
          },
        ],
      },
    ],
  },
  {
    platformName: '模型训练',
    platformKey: 'training',
    authKeys: ['VIEW_TRAIN', 'TRAIN_MGMT'],
    icon: (
      <Image
        alt="推理平台icon"
        height={12}
        src="/assets/images/layout/inference-icon.svg"
        width={12}
      />
    ),
    icon2x: (
      <Image
        alt="推理平台icon"
        height={24}
        src="/assets/images/layout/inference-icon.svg"
        width={24}
      />
    ),
    hasAuthPathname: [
      'training/fineTuning',
      'training/fineTuning/raw/taskDetails',
      /^training\/fineTuning\/raw\/finetuntask\/\d+$/,
    ],
    children: [
      {
        label: '训练列表',
        key: 'training/start',
      },
    ],
  },
  {
    platformName: '资源管理',
    platformKey: 'resource',
    authKeys: ['VIEW_PAGE'],
    icon: (
      <Image
        alt="推理平台icon"
        height={12}
        src="/assets/images/resource/resource-icon.svg"
        width={12}
      />
    ),
    icon2x: (
      <Image
        alt="推理平台icon"
        height={24}
        src="/assets/images/resource/resource-icon.svg"
        width={24}
      />
    ),
    children: [
      {
        label: '计算资源',
        key: 'resource/compute',
      },
      {
        label: '资源组管理',
        key: 'resource/management',
      },
    ],
  },
  {
    platformName: '系统管理',
    platformKey: 'management',
    close: TYPE === 'uss',
    authKeys: ['ADMIN'],
    icon: (
      <Image
        alt="系统管理icon"
        height={12}
        src="/assets/images/layout/system-management.svg"
        width={12}
      />
    ),
    icon2x: (
      <Image
        alt="系统管理icon"
        height={24}
        src="/assets/images/layout/system-management.svg"
        width={24}
      />
    ),
    children: [
      {
        label: '用户管理',
        key: 'management/user',
      },
      {
        label: '角色管理',
        key: 'management/role',
      },
    ],
  },
  {
    platformName: '数据标注',
    platformKey: 'annotation',
    authKeys: ['VIEW_PAGE'],
    icon: (
      <Image
        alt="数据标注icon"
        height={12}
        src="/assets/images/resource/resource-icon.svg"
        width={12}
      />
    ),
    icon2x: (
      <Image
        alt="数据标注icon"
        height={24}
        src="/assets/images/resource/resource-icon.svg"
        width={24}
      />
    ),
    children: [
      {
        label: '任务管理',
        key: 'annotation/taskManagement',
        hasAuthPathname: [
          /^annotation\/taskManagement\/newTask\/\d+$/,
          'annotation/taskManagement/newTask',
        ],
      },
      {
        label: '标注任务',
        key: 'annotation/task',
      },
      {
        label: '标注管理',
        key: 'annotation/dimension',
      },
    ],
  },
];

const CLOSE_MENU_ARRAY =
  TYPE !== 'uss' ? process.env.NEXT_PUBLIC_POC_CLOSE_MENU?.split(',') ?? [] : [];

const handleSidebarConfigRes = (sidebarConfigVal: SidebarConfig[]) => {
  const firstFilterRes = sidebarConfigVal.filter((item) => {
    if (CLOSE_MENU_ARRAY.includes(item.platformKey) || item.close) {
      return false;
    }
    return true;
  });

  const fn = (childrenVal?: SidebarChildren[]) => {
    childrenVal?.forEach((item, index) => {
      if (CLOSE_MENU_ARRAY.includes(item.key) || item.close) {
        childrenVal.splice(index, 1);
      }
      if (item.children && item.children.length > 0) {
        fn(item.children);
      }
    });
  };

  firstFilterRes.forEach((item) => {
    fn(item.children);
  });

  return firstFilterRes;
};

/* 是否显示隐藏处理后的侧边栏 */
export const sideBarRes = handleSidebarConfigRes(sidebarConfig);

const visibleRoutesFn = (router: SidebarConfig[]): (string | RegExp)[] => {
  const res: (string | RegExp)[] = [];

  if (router.length > 0) {
    const fn = (val: SidebarChildren) => {
      res.push(val.key);
      if (val.hasAuthPathname && val.hasAuthPathname.length > 0) {
        res.push(...val.hasAuthPathname);
      }
      if (val.children && val.children.length > 0) {
        val.children.forEach((child) => {
          fn(child);
        });
      }
    };

    router.forEach((item) => {
      res.push(item.platformKey);
      if (item.hasAuthPathname && item.hasAuthPathname.length > 0) {
        res.push(...item.hasAuthPathname);
      }
      if (item.children && item.children.length > 0) {
        item.children.forEach((child) => {
          fn(child);
        });
      }
    });
  }

  return res;
};

export const visibleRoutersRes = visibleRoutesFn(sideBarRes);

/* 判断路由是否有权限 */
export const handleVisibleRouterResFn = (pathname: string): boolean => {
  const strArr = visibleRoutersRes.filter((item) => typeof item === 'string') as string[];
  const regExpArr = visibleRoutersRes.filter((item) => item instanceof RegExp) as RegExp[];

  let regExpRes = false,
    strRes = false;

  if (regExpArr.length > 0) {
    regExpRes = regExpArr.some((item) => item.test(pathname));
  }
  if (strArr.length > 0) {
    strRes = strArr.some((item) => item === pathname);
  }
  return regExpRes || strRes;
};
```

#### 对于用户是否有权限看到某个页面或者手动输入路由进入无权限页面的处理

##### `Auth` 文件下的 `index.tsx` 文件内容

```tsx
'use client';
import type {AxiosError} from '@kai-llm/utils';
import {HTTP_ERROR_EVENT, USER_JWT_KEY} from '@kai-llm/utils';
import get from 'lodash/get';
import {useCallback, useEffect, useMemo, useState, useRef} from 'react';
import {createContainer} from 'unstated-next';
import Cookies from 'js-cookie';
import {usePathname} from 'next/navigation';
import {debounceToastError} from '@/utils/debounceToastError';
import {getUserInfo} from '@/api/common/user';
import {redirectToLoginUSS, redirectToLoginLocal, clearCookieAndStorage} from '@/utils/utils';
import {handleVisibleRouterResFn} from '@/constants/sidebarConfig';
import NoAuth from '../NoAuth/NoAuth';
import LoadAuthSpinner from './AuthSpinner';
import {useAuth} from './useAuth';
import debounce from 'lodash/debounce';

const toastError = debounceToastError();
const TYPE = process.env.NEXT_PUBLIC_AUTH_TYPE ?? 'uss';
/* 无视权限白名单 */
const WHITELIST = ['/login'];
/* 考虑页面权限白名单 */
const PAGE_WHITELIST = ['/', '/sso', '/error/restricted'];

export const AuthContainer = createContainer(useAuth);

interface AuthProps {
  children: React.ReactNode;
}

const AuthChecker: React.FC<AuthProps> = ({children}) => {
  const {setUserInfo, hasAuth} = AuthContainer.useContainer();
  const [loading, setLoading] = useState<boolean>(true);
  const pathname = usePathname();
  const hasFetchedUserInfoRef = useRef<boolean>(false);

  const fetchUserInfo = useCallback(() => {
    setLoading(true);
    getUserInfo()
      .then((res) => {
        setUserInfo(res.data);
        // 写入cookie，保证其他应用可以获取到token
        Cookies.set(USER_JWT_KEY, res.data?.token || '', {expires: 1, domain: '.ai.ksyun.com'});
        typeof window !== 'undefined' &&
          window.localStorage.setItem(USER_JWT_KEY, res.data?.token || '');
        hasFetchedUserInfoRef.current = true;
      })
      .catch((error: AxiosError<{code: number; message: string}>) => {
        const status = error.response?.status;
        if (status) {
          switch (status) {
            case 401:
              /* 在这里清空cookie和localStorage的原因是，在token过期失效的的情况下，删除之前存储的cookie和localStorage，然后重新登录授权 */
              clearCookieAndStorage();
              TYPE === 'uss' ? redirectToLoginUSS() : redirectToLoginLocal();
              break;
          }
        }
      })
      .finally(() => {
        setLoading(false);
      });
  }, [setUserInfo]);

  /** 监听所有网络请求错误 */
  useEffect(() => {
    const eventHandler = (event: Event) => {
      const debouncedFetchUserInfo = debounce(fetchUserInfo, 1000);
      const errorMessage = get(event, 'detail.data.message', '网络请求错误');
      const status: number = get(event, 'detail.status', 200);
      toastError(errorMessage);
      if (status === 401 && pathname !== '/login') {
        hasFetchedUserInfoRef.current = false;
        debouncedFetchUserInfo();
      }
    };

    window.addEventListener(HTTP_ERROR_EVENT, eventHandler);

    return () => {
      window.removeEventListener(HTTP_ERROR_EVENT, eventHandler);
    };
  }, [fetchUserInfo, pathname]);

  useEffect(() => {
    if (pathname !== '/login' && !hasFetchedUserInfoRef.current) {
      fetchUserInfo();
    }
  }, [fetchUserInfo, pathname]);

  const visibleComponent = useMemo(() => {
    if (WHITELIST.includes(pathname)) {
      return children;
    }
    if (loading) {
      return <LoadAuthSpinner />;
    } else if (!hasAuth(['VIEW_PAGE'])) {
      return <NoAuth fullScreen />;
    } else if (PAGE_WHITELIST.includes(pathname)) {
      return children;
    } else if (!handleVisibleRouterResFn(pathname.slice(1))) {
      return <NoAuth fullScreen />;
    }
    return children;
  }, [loading, children, hasAuth, pathname]);

  return <div>{visibleComponent}</div>;
};

export const Auth: React.FC<AuthProps> = ({children}) => {
  return (
    <AuthContainer.Provider>
      <AuthChecker>{children}</AuthChecker>
    </AuthContainer.Provider>
  );
};
```

#### `apps/page.tsx` 文件内容

```tsx
'use client';
import React, {useEffect} from 'react';
import {redirect} from 'next/navigation';
import {AuthContainer} from '@/components/Auth';
import type {SidebarChildren, SidebarConfig} from '@/constants/sidebarConfig';
import {sideBarRes} from '@/constants/sidebarConfig';
import LoadAuthSpinner from '@/components/Auth/AuthSpinner';
import {adminKeys} from '@/constants/authedKeys';

export default function Home(): React.ReactElement {
  const {userInfo} = AuthContainer.useContainer();

  useEffect(() => {
    // 获取用户当前有权限的第一个平台
    // 然后跳转到第一个平台的第一个路由
    if (userInfo?.permissions) {
      const firstPermissionPlatform = sideBarRes.find((item) => {
        const needKeys = item.authKeys ? [...item.authKeys, ...adminKeys] : [...adminKeys];
        return needKeys.some((key) => userInfo.permissions.includes(key));
      });

      const getEndChildren = (val: SidebarConfig | undefined | SidebarChildren) => {
        if (val) {
          if (val.children && val.children.length > 0) {
            getEndChildren(val.children[0]);
          } else {
            redirect(`/${(val as SidebarChildren).key}`);
          }
        } else {
          // 如果有访问权限，但是没有配置路由，跳转到无权限页面
          redirect('/error/restricted');
        }
      };
      getEndChildren(firstPermissionPlatform);
    }
  }, [userInfo?.permissions]);
  return (
    <div>
      <LoadAuthSpinner />
    </div>
  );
}
```







