# 前端权限控制方法实践

## 方法一

这种方法包括了对页面和菜单项的权限控制。页面主要是在子页面或者组件上包裹一层组件，然后在这个组件中判断用户是否有权限展示这个子组件或者页面；菜单项主要是在写菜单项配置时加上当前菜单项所需的权限，然后在编写菜单组件时，过滤掉没有权限的菜单配置项，然后再过滤后的菜单配置项传给菜单组件。

这里还有一个兼容性的写法：如果当前用户拥有管理员权限但是没有某个子页面或者菜单项的权限，但是如果规定只要是管理员就拥有系统的所有权限，那么就可以在本地将管理员权限注入到每个子页面或者菜单项中。

```ts
export const adminKeys = ['ADMIN', 'RUN_AS_ADMIN'];
```

```tsx
import {adminKeys} from '@/constants/authedKeys';

const shouldWithAdminKeys = [...shouldKeys, ...adminKeys];
```

### 对于页面

对于页面是否有权限展示实现一个权限控制组件包括要展示的页面或者子组件，传入要展示这个页面或者子组件所需的权限，然后进行判断用户是否有这个权限。

#### AuthLayout

```tsx
'use client';

import React from 'react';
import NoAuth from '../NoAuth/NoAuth';
import {AuthContainer} from '.';

interface AuthLayoutProps {
  needAuthKeys: string[];
  children: React.ReactNode;
}

const AuthLayout: React.FC<AuthedLayoutProps> = ({needAuthKeys, children}) => {
  const {hasAuth} = AuthContainer.useContainer();

  return <>{hasAuth(needAuthKeys) ? children : <NoAuth />}</>;
};

export default AuthLayout;
```

#### 子页面或者子组件

```tsx
import React, {Suspense} from 'react';
import AuthLayout from '@/components/Auth/AuthLayout';
import DashLayout from '@/components/Layout/DashLayout';

interface ManagementLayoutProps {
  children: React.ReactNode;
}

const ManagementLayout: React.FC<ManagementLayoutProps> = ({children}) => {
  return (
    <DashLayout>
      <Suspense>
        <AuthLayout needAuthKeys={['ADMIN']}>{children}</AuthLayout>
      </Suspense>
    </DashLayout>
  );
};

export default ManagementLayout;
```

#### CPT-4o 解释

你的代码使用了`unstated-next`库来创建一个全局的状态管理容器，并在多个组件中共享和访问该状态。下面是对各部分代码的解释：

##### useAuth.ts 文件

这个文件定义了一个自定义的钩子函数 `useAuth`，用于管理用户认证信息和权限检查逻辑。

```javascript
import { useCallback, useState } from 'react';
import type { Auth } from '@/interfaces/auth';
import { adminKeys } from '@/constants/authedKeys';

export function useAuth() {
  const [userInfo, setUserInfo] = useState<Auth.User | undefined>();

  /**
   * 判断是否有权限
   */
  const hasAuth = useCallback(
    (shouldKeys: string[]) => {
      const shouldWithAdminKeys = [...shouldKeys, ...adminKeys];
      if (!userInfo?.permissions) {
        return false;
      }
      return userInfo.permissions.some((key) => shouldWithAdminKeys.includes(key));
    },
    [userInfo?.permissions],
  );

  return {
    userInfo,
    setUserInfo,
    hasAuth,
  };
}
```

1. `useState` 用于声明 `userInfo` 状态变量，该变量存储当前用户信息。
2. `setUserInfo` 用于更新用户信息。
3. `useCallback` 用于定义 `hasAuth` 函数，该函数接收一个权限数组 `shouldKeys`，判断当前用户是否拥有这些权限。它将传入的权限数组 `shouldKeys` 与管理员权限数组 `adminKeys` 合并，然后检查 `userInfo.permissions` 是否包含这些权限中的任意一个。
4. 返回一个对象，包括 `userInfo`、`setUserInfo` 和 `hasAuth`，以供其他组件使用。

##### index.tsx 文件

这个文件使用 `unstated-next` 库的 `createContainer` 函数创建一个状态容器 `AuthContainer`。

```javascript
import { createContainer } from 'unstated-next';
export const AuthContainer = createContainer(useAuth);
```

1. `createContainer` 接收一个钩子函数（这里是 `useAuth`）作为参数，创建一个状态容器 `AuthContainer`。
2. 其他组件可以通过 `AuthContainer.Provider` 提供状态，并通过 `AuthContainer.useContainer` 使用状态。

##### AuthedLayout.tsx 文件

这个文件定义了一个受保护的布局组件 `AuthedLayout`，它会根据用户权限决定是否显示子组件。

```javascript
'use client';

import React from 'react';
import NoAuth from '../NoAuth/NoAuth';
import { AuthContainer } from '.';

interface AuthedLayoutProps {
  authedKeys: string[];
  children: React.ReactNode;
}

const AuthedLayout: React.FC<AuthedLayoutProps> = ({ authedKeys, children }) => {
  const { hasAuth } = AuthContainer.useContainer();

  return <>{hasAuth(authedKeys) ? children : <NoAuth />}</>;
};

export default AuthedLayout;
```

1. `AuthContainer.useContainer` 用于获取 `useAuth` 中定义的状态和方法。
2. `AuthedLayout` 组件接收 `authedKeys` 和 `children` 作为属性。
3. `hasAuth(authedKeys)` 用于检查当前用户是否拥有必要的权限。
4. 如果用户有权限，显示子组件 `children`；否则，显示 `NoAuth` 组件。

##### 为什么这样写

1. **解耦状态管理和组件逻辑**：`useAuth` 钩子函数集中管理用户信息和权限检查逻辑，减少了代码重复，提高了可维护性。
2. **全局状态共享**：使用 `unstated-next` 创建的状态容器 `AuthContainer` 允许在多个组件之间共享和访问用户信息和权限状态。
3. **简化权限检查**：`AuthedLayout` 组件利用 `hasAuth` 方法简化了权限检查逻辑，使得受保护的路由和组件能够轻松地基于用户权限进行条件渲染。

这种写法可以提高代码的可维护性和可复用性，同时提供灵活的权限管理和状态共享机制。

### 对于菜单

控制菜单项是否是在写菜单项配置时加上当前菜单项所需的权限，然后在编写菜单组件时，过滤掉没有权限的菜单配置项，然后再过滤后的菜单配置项传给菜单组件。

#### siderbarConfig 配置

```tsx
export const sidebarConfig: SiderBarConfig[] = [
  {
    platformName: '数据中心',
    platformKey: 'datasets',
    close: CLOSE_MENS_ARRAY.includes('datasets'),
    authKeys: ['VIEW_DATA', 'DATA_MGMT'],	// 配置的所需权限
    icon: (
      <Image
        alt="数据中心icon"
        height={12}
        src="/assets/images/layout/data-center-icon.svg"
        width={12}
      />
    ),
    icon2x: (
      <Image
        alt="数据中心icon"
        height={24}
        src="/assets/images/layout/data-center-icon.svg"
        width={24}
      />
    ),
    routers: [
      {
        label: '数据集管理',
        key: 'datasets/manage',
      },
      {
        label: '数据洞察',
        key: 'datasets/insight',
      },
      {
        label: '数据清洗',
        key: 'datasets/clean',
      },
      {
        label: '数据制备',
        key: 'datasets/prepare',
      },
    ],
  },
  {
    platformName: '模型评测',
    platformKey: 'evaluation',
    close: CLOSE_MENS_ARRAY.includes('evaluation'),
    authKeys: ['VIEW_EVAL', 'EVAL_MGMT'],
    icon: (
      <Image
        alt="模型评测icon"
        height={12}
        src="/assets/images/layout/model-evaluation-icon.svg"
        width={12}
      />
    ),
    icon2x: (
      <Image
        alt="模型评测icon"
        height={24}
        src="/assets/images/layout/model-evaluation-icon.svg"
        width={24}
      />
    ),
    routers: [
      {
        label: '自动评测',
        key: 'evaluation/model/auto',
      },
    ],
  }
  // ...
];
```

#### 菜单关闭之后的 item 元素

```tsx
const transformedSidebarConfig = useMemo(() => {
  // 如果没有权限，直接返回空数组
  if (!userInfo?.permissions) return [];
  return sidebarConfig
    .filter((item) => item.close === false)
    .filter((item) => {
      const needKeys = item.authKeys ? [...item.authKeys, ...adminKeys] : adminKeys;
      return needKeys.some((key) => userInfo.permissions.includes(key));
    })
    .map((item) => {
      return {
        label: item.platformName,
        key: item.platformKey,
        icon: item.icon2x,
        children: item.routers,
      };
    });
}, [userInfo?.permissions]);

const collapsedMenu = useMemo(() => {
  return (
    <Menu
      className={classNames('text-xs mt-5', styles.dashlayoutMenuCollaspsed)}
      items={transformedSidebarConfig}
      onSelect={({key}) => {
        router.push(`/${key}`);
      }}
      selectedKeys={[selectKey || 'datasets']}
    />
  );
}, [transformedSidebarConfig, selectKey, router]);
```

#### 菜单打开时的 item 元素

```tsx
const siderbarWithAuth = useMemo(() => {
  if (!userInfo?.permissions) return [];

  return sidebarConfig
    .filter((item) => item.close === false)
    .filter((item) => {
      const needKeys = item.authKeys ? [...item.authKeys, ...adminKeys] : adminKeys;
      return needKeys.some((key) => userInfo.permissions.includes(key));
    });
}, [userInfo?.permissions]);
```

#### Menu 菜单

```tsx
<Sider
  className={`${styles.sider} relative z-[801] shadow-[0px_0px_8px_0px_rgba(0,0,0,0.14)] py-1`}
  collapsed={collapsed}
  width={216}
>
  {collapsed
    ? collapsedMenu
    : siderbarWithAuth.map((item) => (
        <div key={item.platformKey}>
          <div className="flex gap-1 items-center my-3 ml-6">
            {item.icon}
            <span className="text-[10px] text-[#838F9A] font-[400] leading-[18px]">
              {item.platformName}
            </span>
          </div>
          <Menu
            className={classNames(styles.menuExpanded, 'text-xs')}
            items={item.routers}
            mode="inline"
            onOpenChange={(keys) => {
              setOpenKeys(keys);
            }}
            onSelect={({key}) => {
              router.push(`/${key}`);
            }}
            openKeys={openKeys}
            selectedKeys={[selectKey || 'knowledge/create']}
            style={{border: 'none'}}
          />
        </div>
      ))}
  {/* ... */}
</Sider>
```



