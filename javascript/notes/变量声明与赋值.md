# 变量声明与赋值

## 使用未声明的变量

在严格模式下，如果试图使用未声明的变量， 那代码运行时会触发引用错误。但在严格模式外部，如果将一个值 赋给尚未使用let、const或var声明的名字，则会创建一个新全局变 量。而且，无论这个赋值语句在函数或代码块中被嵌套了多少次， 都会创建一个全局变量。这肯定不是我们想要的，非常容易招致缺 陷，也是推荐使用严格模式一个最好的理由。

以这种意外方式创建的全局变量类似使用var声明的全局变量， 都定义全局对象的属性。但与通过恰当的var声明定义的属性不同， 这些属性可以通过delete操作删除。

## 解构赋值

```js
let [x,y] = [1,2];	// 相当于 let x=1，y=2
[x,y] = [x+1,y+1];	// 相当于x=x+1,y=y+1        
[x,y] = [y,x];	// 交换两个变量的值
[x,y]	// [3,2]: 递增和交换后的值
```

解构赋值左侧变量的个数不一定与右侧数组中元素的个数相 同。左侧多余的变量会被设置为undefined，而右侧多余的值会被忽略。左侧的变量列表可以包含额外的逗号，以跳过右侧的某些值：

```js
let [x,y] = [1];	// x == 1; y == undefined
[x,y] = [1,2,3];	// x== 1; y == 2
[,x,,y] = [1,2,3,4];	// x == 2; y == 4
```

在解构赋值时，如果你想把所有未使用或剩余的值收集到一个 变量中，可以在左侧最后一个变量名前面加上3个点(...)：

```js
let [x, ...y] = [1, 2, 3, 4];	// y = [2, 3, 4]
```

数组解构的一个强大特性是它并不要求必须是数组!实际上， 赋值的右侧可以是任何可迭代对象，任何可以在 for/of循环中使用的对象也可以被解构：

```js
let [first, ...rest] = "Hello"; // first == "H"; rest == ["e", "1", "1","o"]
```

 解构赋值在右侧是对象值的情况下也可以执行。此时，赋值的
左侧看起来就像一个对象字面量，即一个包含在花括号内的逗号分
隔的变量名列表：

```js
let transparent = { r: 0.0, g: 0.0, b: 0.0, a: 1.0 }; //一个 RGBA 颜色对象
let { r, g, b } = transparent; // r == 0.0; g == 0.0; b == 0.0
```

