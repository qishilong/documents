# 关系表达式

## 相等和不相等操作符

>    =、==和===操作符

### 严格相等

1.   如果两个值类型不同，则不相等。 
2.   如果两个值都是null或都是undefined，则相等。 
3.   如果两个值都是布尔值true或都是布尔值false，则相等。
4.   如果一个或两个值是NaN，则不相等(虽然有点意外，但NaN 确实不等于任何其他值，也包括NaN自身!要检查某个值x是不是 NaN，使用x !== x或全局isNaN()函数)。
5.   如果两个值都是数值且值相同，则相等。如果一个值是0而另 一个是-0，则也相等。
6.   如果两个值都是字符串且相同位置包含完全相同的**16位值**，则相等。如果两个字符串长度或内容不同，则不相等。两个字符串有可能看起来相同，也表示同样的意思，但底层编码却使用不同的16位值序列。JavaScript不会执行Unicode归一化操作，像这样的两个字符串用===或==操作符都不会判定相等。
7.   如果两个值引用同一个对象、数组或函数，则相等。如果它们引用不同的对象，即使两个对象有完全相同的属性，也不相等。

### 基于类型转换的相等

相等操作符==与严格相等类似，但没那么严格。如果两个操作 数的值类型不同，它会尝试做类型转换，然后再比较。

1.   如果两个值类型相同，则按照前面的规则测试它们是否严格相等。如果严格相等，则相等。如果不严格相等，则不相等。
2.   如果两个值类型不同，==操作符仍然可能认为它们相等。此 时它会使用以下规则，基于类型转换来判定相等关系。
3.   如果一个值是null，另一个值是undefined，则相等。
4.   如果一个值是数值，另一个值是字符串，把字符串转换为数值，再比较转换后的数值。
5.   如果有一个值为true，把它转换为1，再比较。如果有一个值 为false，把它转换为0，再比较。
6.   如果一个值是对象，另一个值是数值或字符串，先使用3.9.3 节描述的算法把对象转换为原始值，再比较。对象转换为原始值时 要么使用其toString()方法，要么使用其valueOf()方法。 JavaScript内置的核心类先尝试使用valueOf()，再尝试 toString()。但Date类是个例外，这个类执行toString()转换。
7.   其他任何值的组合都不相等。

![image-20240113204334486](https://qiniucloud.qishilong.space/images/image-20240113204334486.png)

## 比较操作符

### `<` `>` `<=` `>=` 

<操作符在第一个操作数小于第二个操作数时求值为true，否则 求值为false。

\>操作符在第一个操作数大于第二个操作数时求值为true，否则 求值为false。

<=操作符在第一个操作数小于或等于第二个操作数时求值为 true，否则求值为false。

\>=操作符在第一个操作数大于或等于第二个操作数时求值为 true，否则求值为false。

这几个比较操作符的操作数可能是任何类型。但比较只能针对数值和字符串，因此不是数值或字符串的操作数会被转换类型。

比较和转换规则如下：

1. 如果有操作数求值为对象，该对象会按照3.9.3节的描述被转 换为原始值。即如果它的valueOf()方法返回原始值，就使用这个 值，否则就使用它的toString()方法返回的值。
2. 如果在完成对象到原始值的转换后两个操作数都是字符串， 则使用字母表顺序比较这两个字符串，其中“字母表顺序”就是组 成字符串的16位Unicode值的数值顺序。
3. 如果在完成对象到原始值的转换后至少有一个操作数不是字 符串，则两个操作数都会被转换为数值并按照数值顺序来比较。0 和-0被认为相等。Infinity比它本身之外的任何数都大，-Infinity 比它本身之外的任何数都小。如果有一个操作数是(或转换后是) NaN，则这些比较操作符都返回false。虽然算术操作符不允许 BigInt值与常规数值混用，但比较操作符允许数值与BigInt进行比较。

如果需要更可靠的字符串比较算法，可以用 String.localeCompare()方法，这个方法也会考虑特定地区的字母 表顺序。要执行不区分大小写的比较，可以使用 String.toLowerCase()或String.toUpperCase()把字符串转换为全 小写或全大写。如果需要更通用和更好的本地化字符串比较工具， 可以使用Intl.Collator类。

+操作符和比较操作符同样都会对数值和字符串操作数区别对 待。+偏向字符串，即只要有一个操作数是字符串，它就会执行拼接操作。而比较操作符偏向数值，只有两个操作数均为字符串时才按
字符串处理：

```js
1 + 2; // => 3：相加
"1" + "2"; // => "12"：拼接
"1" + 2; // => "12": 2 会转换为"2"
11 < 3; // => false：数值比较
"11" < "3"; // => true：字符串比较
"11" < 3; // => false：数值比较，"11"会转换为 11
"one" < 3; // => false：数值比较，"one"转换为 NaN
```

最后，注意<=(小于或等于)和>=(大于或等于)操作符不依 赖相等或严格相等操作符确定两个值是否“相等”。其中，小于或 等于操作符只是简单地定义为“不大于”，而大于或等于操作符则 定义为“不小于”。还有一个例外情形，即只要有一个操作数是 (或可以转换为)NaN，则全部4个比较操作符都返回false。

## `in` 操作符

in操作符期待左侧操作数是字符串、符号或可以转换为字符串 的值，期待右侧操作数是对象。如果左侧的值是右侧的对象的属性名，则in返回true。例如：

```js
let point = { x: 1, y: 1 }; // 定义对象
"x" in point; // => true：对象有名为"x"的属性
"z" in point; // => false：对象没有名为"z”的属性
"toString" in point; // => true：对象继承了 toString 方法
let data = [7, 8, 9]; // 数组，有元素（索引）0、1和 2
"0" in data; // => true：数组有元素"0"
1 in data; // => true：数值会转换为字符串
3 in data; // => false：没有元素 3
```

## `instanceof` 操作符

instanceof操作符期待左侧操作数是对象，右侧操作数是对象类的标识。这个操作符在左侧对象是右侧类的实例时求值为true， 否则求值为false。

注意，所有对象都是Object的实例。instanceof在确定对象是 不是某个类的实例时会考虑“超类”。如果instanceof的左侧操作数不是对象，它会返回false。如果右侧操作数不是对象的类，它会 抛出TypeError。

要理解instanceof的工作原理，必须理解“原型链”。原型链 是JavaScript的继承机制，6.3.2节有详细介绍。为了对表达式o instanceof f求值，JavaScript会求值f.prototype，然后在o的原型链上查找这个值。如果找到了，则o是f(或f的子类)的实例， instanceof返回true。如果f.prototype不是o原型链上的一个值， 则o不是f的实例，instanceof返回false。
